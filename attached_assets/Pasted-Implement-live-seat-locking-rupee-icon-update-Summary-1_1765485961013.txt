Implement live seat locking + rupee icon update.

Summary
1. Add Redis-based seat locks with TTL (120s). Endpoints: lock, unlock, list locks.
2. Add SSE stream for seat lock events so clients update in real-time.
3. Integrate frontend: lock when selecting a seat, show locked UI with countdown, unlock on navigation or booking cancel/complete.
4. Add diagnostic endpoints and console logs so we can see why seat locks previously failed.
5. Change fare breakdown icon from dollar to rupee.

Server changes (exact steps)
1. Install Redis client
   - Run inside server folder: `npm install ioredis`
2. Create Redis helper
   - File: `server/src/lib/redis.js` (CREATE)
   - Content (CommonJS):
     ```js
     const IORedis = require('ioredis');
     const redis = new IORedis(process.env.REDIS_URL || 'redis://127.0.0.1:6379');
     module.exports = redis;
     ```
3. Create seat controller and routes
   - File: `server/src/controllers/seatsController.js` (CREATE)
     ```js
     const redis = require('../lib/redis');

     const LOCK_TTL_MS = 120000; // 120s

     function seatLockKey(tripId, seatId){ return `lock:trip:${tripId}:seat:${seatId}`; }

     async function lockSeat(req, res) {
       const { tripId, seatId } = req.params;
       const { userId } = req.body;
       if(!userId) return res.status(400).json({ error: 'userId required' });
       const key = seatLockKey(tripId, seatId);
       const value = JSON.stringify({ userId, createdAt: Date.now() });
       try {
         // Use SET NX PX to atomically set lock with TTL
         const ok = await redis.set(key, value, 'NX', 'PX', LOCK_TTL_MS);
         if(ok === null) {
           const current = await redis.get(key);
           const parsed = current ? JSON.parse(current) : null;
           return res.status(409).json({ locked: true, lockedBy: parsed?.userId, expiresAt: parsed ? Date.now() + LOCK_TTL_MS : null });
         }
         // publish SSE event channel
         await redis.publish(`seat-events:${tripId}`, JSON.stringify({ type: 'lock', seatId, userId, expiresAt: Date.now() + LOCK_TTL_MS }));
         console.log('SEAT LOCKED', { tripId, seatId, userId });
         return res.json({ locked: true, expiresAt: Date.now() + LOCK_TTL_MS });
       } catch(err) {
         console.error('LOCK_SEAT_ERROR', err);
         return res.status(500).json({ error: 'internal' });
       }
     }

     async function unlockSeat(req, res) {
       const { tripId, seatId } = req.params;
       const { userId } = req.body;
       const key = seatLockKey(tripId, seatId);
       try {
         const current = await redis.get(key);
         if(!current) return res.status(404).json({ error: 'not locked' });
         const parsed = JSON.parse(current);
         if(parsed.userId !== userId) return res.status(403).json({ error: 'not owner' });
         await redis.del(key);
         await redis.publish(`seat-events:${tripId}`, JSON.stringify({ type: 'unlock', seatId, userId }));
         console.log('SEAT UNLOCKED', { tripId, seatId, userId });
         return res.json({ unlocked: true });
       } catch(err) {
         console.error('UNLOCK_SEAT_ERROR', err);
         return res.status(500).json({ error: 'internal' });
       }
     }

     async function listLocks(req, res){
       const { tripId } = req.params;
       try {
         const stream = redis.scanStream({ match: `lock:trip:${tripId}:seat:*` });
         const keys = [];
         for await (const resultKeys of stream) { keys.push(...resultKeys); }
         const items = [];
         if(keys.length) {
           const vals = await redis.mget(...keys);
           for(let i=0;i<keys.length;i++){
             const seatId = keys[i].split(':').pop();
             items.push({ seatId, data: vals[i] ? JSON.parse(vals[i]) : null });
           }
         }
         return res.json(items);
       } catch(err) {
         console.error('LIST_LOCKS_ERROR', err);
         return res.status(500).json({ error: 'internal' });
       }
     }

     module.exports = { lockSeat, unlockSeat, listLocks };
     ```
   - File: `server/src/routes/seats.js` (CREATE)
     ```js
     const express = require('express');
     const router = express.Router();
     const { lockSeat, unlockSeat, listLocks } = require('../controllers/seatsController');
     router.post('/:tripId/seats/:seatId/lock', lockSeat);
     router.post('/:tripId/seats/:seatId/unlock', unlockSeat);
     router.get('/:tripId/locks', listLocks);
     module.exports = router;
     ```
   - Register route in main app server (e.g., `server/src/app.js`): `app.use('/api/trips', require('./routes/seats'));`

4. SSE server-side publisher and lightweight SSE helper
   - File: `server/src/routes/seatSse.js` (CREATE)
     ```js
     const express = require('express');
     const router = express.Router();
     const redis = require('../lib/redis');

     router.get('/:tripId/seat-updates', (req, res) => {
       const { tripId } = req.params;
       res.writeHead(200, {
         'Content-Type': 'text/event-stream',
         'Cache-Control': 'no-cache',
         Connection: 'keep-alive'
       });
       const channel = `seat-events:${tripId}`;
       const sub = new (require('ioredis'))(process.env.REDIS_URL || 'redis://127.0.0.1:6379');
       sub.subscribe(channel).then(() => {
         sub.on('message', (ch, msg) => {
           res.write(`event: seat\n`);
           res.write(`data: ${msg}\n\n`);
         });
       });
       req.on('close', () => {
         sub.disconnect();
       });
     });

     module.exports = router;
     ```
   - Register: `app.use('/api/trips', require('./routes/seatSse'));`

5. Add a diagnostic test route (optional)
   - File: `server/src/routes/debug.js` (CREATE)
     ```js
     const express = require('express');
     const router = express.Router();
     const redis = require('../lib/redis');
     router.get('/redis-ping', async (req, res) => {
       try {
         const pong = await redis.ping();
         res.json({ pong });
       } catch(err){ res.status(500).json({ error: String(err) }); }
     });
     module.exports = router;
     ```
   - Register: `app.use('/api/debug', require('./routes/debug'));`

Frontend changes (exact steps)
1. Create a seat lock hook
   - File: `client/src/hooks/useSeatLocks.ts` (CREATE)
     ```ts
     import { useEffect, useState, useRef } from 'react';
     export default function useSeatLocks(tripId: string){
       const [locks, setLocks] = useState<Record<string, { userId: string; expiresAt: number }>>({});
       const evtSourceRef = useRef<EventSource | null>(null);

       useEffect(() => {
         if(!tripId) return;
         const es = new EventSource(`/api/trips/${tripId}/seat-updates`);
         evtSourceRef.current = es;
         es.addEventListener('seat', (e: any) => {
           try {
             const payload = JSON.parse(e.data);
             setLocks(prev => {
               const next = { ...prev };
               if(payload.type === 'lock') next[payload.seatId] = { userId: payload.userId, expiresAt: payload.expiresAt };
               if(payload.type === 'unlock') { delete next[payload.seatId]; }
               return next;
             });
           } catch(err){ console.error('SSE PARSE ERROR', err); }
         });
         // initial fetch
         fetch(`/api/trips/${tripId}/locks`).then(r=>r.json()).then(list=>{
           const obj = {};
           list.forEach(x => { if(x.data) obj[x.seatId] = x.data; });
           setLocks(obj);
         }).catch(e => console.error(e));
         return () => { es.close(); evtSourceRef.current = null; };
       }, [tripId]);

       const lockSeat = async (seatId: string, userId: string) => {
         console.log('ATTEMPT LOCK', { tripId, seatId, userId });
         const res = await fetch(`/api/trips/${tripId}/seats/${seatId}/lock`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ userId }) });
         if(!res.ok) throw await res.json();
         return res.json();
       };

       const unlockSeat = async (seatId: string, userId: string) => {
         const res = await fetch(`/api/trips/${tripId}/seats/${seatId}/unlock`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ userId }) });
         if(!res.ok) throw await res.json();
         return res.json();
       };

       return { locks, lockSeat, unlockSeat };
     }
     ```
2. Update Seat component to use hook
   - File: `client/src/components/SeatMap/Seat.tsx` (UPDATE)
     - On click:
       ```ts
       try {
         await lockSeat(seatId, user.id);
         setSelected(true); // local state
         console.log('SEAT LOCK SUCCESS', seatId);
       } catch(err){
         console.error('SEAT LOCK FAILED', err);
         // show toast: seat locked by others
       }
       ```
     - Display locked state if `locks[seatId] && locks[seatId].userId !== user.id`
     - Show countdown using `locks[seatId].expiresAt - Date.now()`
     - On component unmount or route change call `unlockSeat` for seats the user locked.
3. Update booking page
   - File: `client/src/pages/booking/[id].tsx` (UPDATE)
     - Import and call `useSeatLocks(tripId)`
     - Before final booking verify selected seats still have locks belonging to user; if not, show error and refresh lock list.
     - On successful booking, do not need explicit unlock (booking flow should finalize seats and server can publish unlock/confirm events).

Icon change
1. Replace fare icon (dollar) to rupee
   - Find `client/src/components/FareBreakdownModal.tsx` (or wherever the icon exists)
   - Replace `<IconDollar />` or similar with rupee symbol: `<span className="text-2xl font-bold">₹</span>` or use any rupee icon from lucide or font.
   - Also ensure currency formatting helper uses INR symbol.

Troubleshooting / why locks previously failed (added checks)
1. Check that `REDIS_URL` environment variable is set in Replit Secrets. If not, the server will try local Redis (likely missing). If Replit does not provide Redis you must use a hosted Redis URL (e.g., Upstash) and set REDIS_URL accordingly.
2. Use the diagnostic endpoint: `GET /api/debug/redis-ping` (should return `{"pong":"PONG"}`).
3. Logs: server prints `SEAT LOCKED`, `SEAT UNLOCKED`, `LOCK_SEAT_ERROR` — watch Replit console.

Acceptance criteria
1. Clicking a seat when not locked calls lock endpoint and returns success; UI shows seat highlighted as locked with countdown.
2. Another client (different browser) sees that seat greyed and cannot lock it; receives 409 if attempt.
3. SSE events update clients within a few seconds.
4. Fare breakdown shows rupee symbol.
5. Diagnostic endpoint `GET /api/debug/redis-ping` returns PONG.

Files to be created/updated (agent must return this list)
- server/src/lib/redis.js (CREATE)
- server/src/controllers/seatsController.js (CREATE)
- server/src/routes/seats.js (CREATE)
- server/src/routes/seatSse.js (CREATE)
- server/src/routes/debug.js (CREATE)
- client/src/hooks/useSeatLocks.ts (CREATE)
- client/src/components/SeatMap/Seat.tsx (UPDATE)
- client/src/pages/booking/[id].tsx (UPDATE)
- client/src/components/FareBreakdownModal.tsx (UPDATE) — icon swap

Start implementation now and return:
- the list of changed files,
- Replit console logs showing `SEAT LOCKED` and `SEAT UNLOCKED` for a manual test,
- a screenshot of two browser sessions showing a locked seat with a countdown on the second client,
- output of `GET /api/debug/redis-ping`.

If Redis is unavailable in your Replit environment, respond with that error and I will provide an Upstash (serverless Redis) setup prompt and exact env values to use.
