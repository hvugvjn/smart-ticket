Implement live seat locking to prevent double-booking when users select seats.

Goals
- When a user clicks a seat it becomes LOCKED for 120 seconds for that user.
- Locked seats show a countdown to other users and cannot be selected.
- Locks auto-release after timeout or when booking completes/cancels.
- Use Redis to manage locks (key per seat: lock:trip:<tripId>:seat:<seatId> => {userId, expiresAt}).
- Backend and frontend must handle lock/unlock and show real-time updates (SSE or WebSocket). Use SSE if WebSocket not present.

Server (backend) tasks
1. Add Redis client (ioredis or redis):
   - Install: run in server folder `npm install ioredis`
   - Config from env: REDIS_URL
   - File: server/src/lib/redis.js (create) exports `redis`

2. Add lock endpoints:
   - POST /api/trips/:tripId/seats/:seatId/lock
     Request body: { userId }
     Behavior:
       - Attempt to set Redis key `lock:trip:${tripId}:seat:${seatId}` with value JSON { userId, expiresAt } using `SETNX` or `SET key value NX PX 120000`.
       - If success return 200 { locked: true, expiresAt }
       - If already locked return 409 { locked: true, lockedBy, expiresAt }
       - Log: console.log('SEAT LOCK ATTEMPT', { tripId, seatId, userId, result })
   - POST /api/trips/:tripId/seats/:seatId/unlock
     Body { userId }
     Behavior:
       - If key exists and lockedBy === userId, delete key and return 200.
       - Else return 403 or 404.

3. Add endpoint to fetch all locked seats for a trip:
   - GET /api/trips/:tripId/locks
   - Return list of locked seatIds with expiresAt and userId (or masked id).

4. Ensure clicking Confirm Booking will validate no locks conflict: check Redis locks before finalizing seats, and atomically remove locks during transaction.

5. Add periodic cleanup if needed (Redis TTL handles expiry).

Real-time updates
1. Implement SSE endpoint:
   - GET /api/trips/:tripId/seat-updates (SSE stream)
   - Server publishes events when locks are created/removed and when bookings confirm.
   - Use `res.write('event: locks\ndata: ...\n\n')`
2. When lock/unlock occurs, server pushes SSE event to connected clients for that trip.

Files to change/create (server)
- server/src/lib/redis.js (CREATE)
- server/src/routes/seats.js (CREATE/UPDATE) — mount at /api/trips/:tripId/seats...
- server/src/routes/seatSse.js (CREATE) or add SSE route to seats route
- server/src/controllers/seatsController.js (CREATE)
- server/src/app.js / server/src/index.js — add redis init and route registration

Frontend tasks
1. When user hovers/selects a seat, call POST lock endpoint to reserve for 120s:
   - client/src/components/SeatMap/Seat.tsx — onClick attempt lock then set local selection only if lock success
   - Console log: `console.log('SEAT LOCKED', {tripId, seatId, expiresAt})`
2. Start SSE connection for currently viewed trip:
   - client/src/pages/booking/[id].tsx — subscribe to `/api/trips/:id/seat-updates`
   - On events, update UI to show locked seats with countdown timers (expiresAt - now).
3. When user navigates away, calls unlock for any seats they locked.
4. When booking completes successfully, unlock those seats server-side (handled by booking flow) and update UI via SSE event.

Files to change/create (client)
- client/src/components/SeatMap/Seat.tsx (UPDATE)
- client/src/pages/booking/[id].tsx (UPDATE)
- client/src/hooks/useSeatLocks.ts (CREATE) — hook to manage SSE and lock state

Acceptance
- Simulate two browser sessions. User A locks seat L4B — User B sees L4B greyed out with countdown. If User A confirms within 120s seat becomes confirmed and removed from available; otherwise it returns to available after timeout.
- Console logs show SEAT LOCK ATTEMPT and SSE events for locks/unlocks.
- If lock endpoint is called while locked, response 409 is returned and UI shows lockedBy notice.

Start now and return changed file list and one screenshot showing a locked seat with countdown from a different client session.
